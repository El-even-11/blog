<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CMU15-445 Project4 Concurrency Control | Eleven's Blog</title><meta name=keywords content="Database"><meta name=description content="Supporting Concurrent Query in Bustub."><meta name=author content="Me"><link rel=canonical href=https://canonical.url/to/page><link crossorigin=anonymous href=/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css integrity="sha256-7I2jZsovtkdTfMt6j2+ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.eleven.wiki/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://blog.eleven.wiki/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://blog.eleven.wiki/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://blog.eleven.wiki/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://blog.eleven.wiki/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-4XHWHM02GB"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4XHWHM02GB",{anonymize_ip:!1})}</script><meta property="og:title" content="CMU15-445 Project4 Concurrency Control"><meta property="og:description" content="Supporting Concurrent Query in Bustub."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.eleven.wiki/posts/cmu15-445-project4-concurrency-control/"><meta property="og:image" content="https://blog.eleven.wiki/%3Cimage%20path/url%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-17T20:20:04+08:00"><meta property="article:modified_time" content="2022-12-17T20:20:04+08:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.eleven.wiki/%3Cimage%20path/url%3E"><meta name=twitter:title content="CMU15-445 Project4 Concurrency Control"><meta name=twitter:description content="Supporting Concurrent Query in Bustub."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.eleven.wiki/posts/"},{"@type":"ListItem","position":3,"name":"CMU15-445 Project4 Concurrency Control","item":"https://blog.eleven.wiki/posts/cmu15-445-project4-concurrency-control/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CMU15-445 Project4 Concurrency Control","name":"CMU15-445 Project4 Concurrency Control","description":"Supporting Concurrent Query in Bustub.","keywords":["Database"],"articleBody":"完结撒花！临近期末周了，来摸摸鱼记录一下 Bustub Concurrency Control 的实现过程。\n非常感谢 CMU 慷慨地开源如此优质的课程。\nResources https://15445.courses.cs.cmu.edu/fall2022 课程官网 https://github.com/cmu-db/bustub Bustub Github Repo https://www.gradescope.com/ 自动测评网站 GradeScope，course entry code: PXWVR5 https://discord.gg/YF7dMCg Discord 论坛，课程交流用 bilibili 有搬运的课程视频，自寻。 请不要将实现代码公开，尊重 Andy 和 TAs 的劳动成果！\nOverview Project 4 是 15-445 2022Fall 的最后一个部分了，在这里我们将为 Bustub 实现关系数据库中极其重要的 transaction 概念。难度上来说个人感觉 Project 2 » 4 \u003e 3 ≈ 1。Project 4 实现难度还是不小的，分为三个部分：\nLock Manager：锁管理器，利用 2PL 实现并发控制。支持 REPEATABLE_READ、READ_COMMITTED 和 READ_UNCOMMITTED 三种隔离级别，支持 SHARED、EXCLUSIVE、INTENTION_SHARED、INTENTION_EXCLUSIVE 和 SHARED_INTENTION_EXCLUSIVE 五种锁，支持 table 和 row 两种锁粒度，支持锁升级。Project 4 重点部分。 Deadlock Detection：死锁检测，运行在一个 background 线程，每间隔一定时间检测当前是否出现死锁，并挑选合适的事务将其 abort 以解开死锁。 Concurrent Query Execution：修改之前实现的 SeqScan、Insert 和 Delete 算子，加上适当的锁以实现并发的查询。 Task 1 Lock Manager 大部分需要注意的内容都在 lock_manager.h 的 LOCK NOTE 和 UNLOCK NOTE 里了。在开始实现前务必阅读。\n首先理一理 Lock Manager 的结构：\ntable_lock_map_：记录 table 和与其相关锁请求的映射关系。 row_lock_map_：记录 row 和与其相关锁请求的映射关系。 这两个 map 的值均为锁请求队列 LockRequestQueue：\nrequest_queue_：实际存放锁请求的队列。 cv_ \u0026 latch_：条件变量和锁，配合使用可以实现经典的等待资源的模型。 upgrading_：正在此资源上尝试锁升级的事务 id。 锁请求以 LockRequest 类表示：\ntxn_id_：发起此请求的事务 id。 lock_mode_：请求锁的类型。 oid_：在 table 粒度锁请求中，代表 table id。在 row 粒度锁请求中，表示 row 属于的 table 的 id。 rid_：仅在 row 粒度锁请求中有效。指 row 对应的 rid。 granted_：是否已经对此请求授予锁？ Lock Manager 的作用是处理事务发送的锁请求，例如有一个 SeqScan 算子需要扫描某张表，其所在事务就需要对这张表加 S 锁。而加读锁这个动作需要由 Lock Manager 来完成。事务先对向 Lock Manager 发起加 S 锁请求，Lock Manager 对请求进行处理。如果发现此时没有其他的锁与这个请求冲突，则授予其 S 锁并返回。如果存在冲突，例如其他事务持有这张表的 X 锁，则 Lock Manager 会阻塞此请求（即阻塞此事务），直到能够授予 S 锁，再授予并返回。\n现在可能还有点迷糊，接下来理一理 lock 和 unlock 的整个过程应该就比较清晰了。\nLock 以 table lock 为例。首先需要注意，Project 4 中细节极多，每次操作都有很多状态需要同步和维护，因此尽量遵循防御性编程的理念，多用 assert，确保系统处于预期的状态。\n第一步，检查 txn 的状态。\n若 txn 处于 Abort/Commit 状态，抛逻辑异常，不应该有这种情况出现。\n若 txn 处于 Shrinking 状态，则需要检查 txn 的隔离级别和当前锁请求类型：\nREPEATABLE_READ: The transaction is required to take all locks. All locks are allowed in the GROWING state No locks are allowed in the SHRINKING state READ_COMMITTED: The transaction is required to take all locks. All locks are allowed in the GROWING state Only IS, S locks are allowed in the SHRINKING state READ_UNCOMMITTED: The transaction is required to take only IX, X locks. X, IX locks are allowed in the GROWING state. S, IS, SIX locks are never allowed 三种隔离级别翻译成中文分别是可重复读、读已提交、读未提交。另外 lecture 中一直提到的 SERIALIZABLE 可串行化隔离级别在 Project 4 中无需实现。实现 SERIALIZABLE 需要在 REPEATABLE_READS 的基础上加上 index lock。这里我们无需关注 index lock。\n以下是 15-445 Lecture 17 slides 中的截图，介绍了不同隔离级别下可能出现的异常情况：\n不同的隔离级别其实是性能与一致性的权衡。关于隔离级别的更多内容可以看看 15-445 的 Lecture。\n在 Project 4 中仅需支持除了 SERIALIZABLE 外的剩下三种隔离级别。若 txn 处于 Shrinking 状态：\n在 REPEATABLE_READ 下，造成事务终止，并抛出 LOCK_ON_SHRINKING 异常。 在 READ_COMMITTED 下，若为 IS/S 锁，则正常通过，否则抛 LOCK_ON_SHRINKING。 在 READ_UNCOMMITTED 下，若为 IX/X 锁，抛 LOCK_ON_SHRINKING，否则抛 LOCK_SHARED_ON_READ_UNCOMMITTED。 若 txn 处于 Growing 状态，若隔离级别为 READ_UNCOMMITTED 且锁类型为 S/IS/SIX，抛 LOCK_SHARED_ON_READ_UNCOMMITTED。其余状态正常通过。\n第一步保证了锁请求、事务状态、事务隔离级别的兼容。正常通过第一步后，可以开始尝试获取锁。\n第二步，获取 table 对应的 lock request queue。\n从 table_lock_map_ 中获取 table 对应的 lock request queue。注意需要对 map 加锁，并且为了提高并发性，在获取到 queue 之后立即释放 map 的锁。若 queue 不存在则创建。\n第三步，检查此锁请求是否为一次锁升级。\n首先，记得对 queue 加锁。\ngranted 和 waiting 的锁请求均放在同一个队列里，我们需要遍历队列查看有没有与当前事务 id（我习惯叫做 tid）相同的请求。如果存在这样的请求，则代表当前事务在此前已经得到了在此资源上的一把锁，接下来可能需要锁升级。需要注意的是，这个请求的 granted_ 一定为 true。因为假如事务此前的请求还没有被通过，事务会被阻塞在 LockManager 中，不可能再去尝试获取另一把锁。\n现在我们找到了此前已经获取的锁，开始尝试锁升级。首先，判断此前授予锁类型是否与当前请求锁类型相同。若相同，则代表是一次重复的请求，直接返回。否则进行下一步检查。\n接下来，判断当前资源上是否有另一个事务正在尝试升级（queue-\u003eupgrading_ == INVALID_TXN_ID）。若有，则终止当前事务，抛出 UPGRADE_CONFLICT 异常。因为不允许多个事务在同一资源上同时尝试锁升级。\n[LOCK UPGRADE] Furthermore, only one transaction should be allowed to upgrade its lock on a given resource. Multiple concurrent lock upgrades on the same resource should set the TransactionState as ABORTED and throw a TransactionAbortException (UPGRADE_CONFLICT).\n为什么不允许？TODO!\n然后，判断升级锁的类型和之前锁是否兼容，不能反向升级。\nWhile upgrading, only the following transitions should be allowed: IS -\u003e [S, X, IX, SIX] S -\u003e [X, SIX] IX -\u003e [X, SIX] SIX -\u003e [X]\n若不兼容，抛 INCOMPATIBLE_UPGRADE 异常。\n现在，我们终于可以进行锁升级了。引用 Discord 里 15-445 TA 的原话，锁升级可以被拆分成三个步骤：\n可以升级吗？即我们此前的一系列判断。 释放当前已经持有的锁，并在 queue 中标记我正在尝试升级。 等待直到新锁被授予。 需要特别注意的是，在锁升级时，需要先释放此前持有的锁，把升级作为一个新的请求加入队列。之前我以为在锁升级时要一直持有此前的锁，直到能够升级时，再直接修改锁的类型。按此实现之后被一个 test case 卡到怀疑人生。\n锁升级的步骤大概就是这样。当然，假如遍历队列后发现不存在与当前 tid 相同的请求，就代表这是一次平凡的锁请求。\n第四步，将锁请求加入等待队列。\nnew 一个 LockRequest，加入队列尾部。实际上这里 LockRequest 不应该设计成裸指针，不方便管理，之后要记得手动释放。最好用智能指针。没用智能指针的原因是忘了（不过完全可以自己改成智能指针。\n这里采用一条队列，把 granted 和 waiting 的请求放在一起，个人感觉不是特别清晰。或许可以改成一条 granted 队列和一条 waiting 队列。\n第五步，尝试获取锁。\n这是最后一步，也是最核心的一步，体现了 Lock Manager 的执行模型。首先，需要清楚条件变量的使用场景。\n条件变量并不是某一个特定语言中的概念，而是操作系统中线程同步的一种机制。先给出条件变量经典的使用形式：\nstd::unique_lock\u003cstd::mutex\u003e lock(latch); while (!resource) { cv.wait(lock); } 条件变量与互斥锁配合使用。首先需要持有锁，并查看是否能够获取资源。这个锁与资源绑定，是用来保护资源的锁。若暂时无法获取资源，则调用条件变量的 wait 函数。调用 wait 函数后，latch 将自动释放，并且当前线程被挂起，以节省资源。这就是阻塞的过程。此外，允许有多个线程在 wait 同一个 latch。\n当其他线程的活动使得资源状态发生改变时，需要调用条件遍历的 notify_all() 函数。即\n// do something changing the state of resource... cv.notify_all(); notify_all() 可以看作一次广播，会唤醒所有正在此条件变量上阻塞的线程。在线程被唤醒后，其仍处于 wait 函数中。在 wait 函数中尝试获取 latch，若成功获取则返回，再次检查是否能获取 resource，若仍不能获取，就继续进入 wait 阻塞，释放锁，挂起线程。若能获取，则退出循环。这样就实现了阻塞等待资源的模型。条件变量中的条件指的就是满足某个条件，在这里即能够获取资源。\n理解条件变量的作用后，就可以写出如下代码：\nstd::unique_lock\u003cstd::mutex\u003e lock(queue-\u003elatch_); while (!GrantLock(...)) { queue-\u003ecv_.wait(lock); } 在 GrantLock() 中，Lock Manager 会判断是否可以满足当前锁请求。若可以满足，则返回 true，事务成功获取锁，并退出循环。若不能满足，则返回 false，事务暂时无法获取锁，在 wait 处阻塞，等待资源状态变化时被唤醒并再次判断是否能够获取锁。资源状态变化指的是什么？有其他事务释放了锁。\n接下来是 GrantLock() 函数。在此函数中，我们需要判断当前锁请求是否能被满足。\n判断兼容性。遍历请求队列，查看当前锁请求是否与所有的已经 granted 的请求兼容。需要注意的是，在我的实现中 granted 请求不一定都在队列头部，因此需要完全遍历整条队列。锁兼容矩阵可以在 Lecture slides 中查看。若全部兼容，则通过检查。否则直接返回 false。当前请求无法被满足。\n判断优先级。锁请求会以严格的 FIFO 顺序依次满足。只有当前请求为请求队列中优先级最高的请求时，才允许授予锁。优先级可以这样判断：\n如果队列中存在锁升级请求，若锁升级请求正为当前请求，则优先级最高。否则代表其他事务正在尝试锁升级，优先级高于当前请求。 若队列中不存在锁升级请求，则遍历队列。如果，当前请求是第一个 waiting 状态的请求，则代表优先级最高。如果当前请求前面还存在其他 waiting 请求，则要判断当前请求是否前面的 waiting 请求兼容。若兼容，则仍可以视为优先级最高。若存在不兼容的请求，则优先级不为最高。 这么说可能比较抽象，举几个具体的例子：\nX(waiting) X(upgrading) ^ current Current request is upgrading. Highest priority. -------------------------------------------------- X(waiting) S(waiting) ^ current Current request is incompatible with the first request. Not highest priority. -------------------------------------------------- S(waiting) S(waiting) ^ current Although current request is not the first waiting request, it is compatible with the first request. Highest priority. 其他的情况都比较好理解，遵循升级请求优先级最高和 FIFO 的原则。但最后一种情况可能稍微不太好理解。之所以要这么做是因为 LOCK NOTE 里有这么一句话：\nIf there are multiple compatible lock requests, all should be granted at the same time as long as FIFO is honoured.\n所有兼容的锁请求需要一起被授予。\n两项检查通过后，代表当前请求既兼容又有最高优先级，因此可以授予锁。授予锁的方式是将 granted_ 置为 true。并返回 true。假如这是一次升级请求，则代表升级完成，还要记得将 upgrading_ 置为 INVALID_TXN_ID。\n另外，需要进行一些 Bookkeeping 操作。Transaction 中需要维护许多集合，分别记录了 Transaction 当前持有的各种类型的锁。方便在事务提交或终止后全部释放。\nLock 的流程大致如此，row lock 与 table lock 几乎相同，仅多了一个检查步骤。在接收到 row lock 请求后，需要检查是否持有 row 对应的 table lock。必须先持有 table lock 再持有 row lock。\nUnlock ","wordCount":"677","inLanguage":"en","image":"https://blog.eleven.wiki/%3Cimage%20path/url%3E","datePublished":"2022-12-17T20:20:04+08:00","dateModified":"2022-12-17T20:20:04+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.eleven.wiki/posts/cmu15-445-project4-concurrency-control/"},"publisher":{"@type":"Organization","name":"Eleven's Blog","logo":{"@type":"ImageObject","url":"https://blog.eleven.wiki/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.eleven.wiki accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://blog.eleven.wiki/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.eleven.wiki/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.eleven.wiki>Home</a>&nbsp;»&nbsp;<a href=https://blog.eleven.wiki/posts/>Posts</a></div><h1 class=post-title>CMU15-445 Project4 Concurrency Control</h1><div class=post-description>Supporting Concurrent Query in Bustub.</div><div class=post-meta><span title='2022-12-17 20:20:04 +0800 +0800'>December 17, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;677 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/el-even-11/blog/content/posts/CMU15-445-Project4-Concurrency-Control.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#resources>Resources</a></li><li><a href=#overview>Overview</a></li><li><a href=#task-1-lock-manager>Task 1 Lock Manager</a><ul><li><a href=#lock>Lock</a></li><li><a href=#unlock>Unlock</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>完结撒花！临近期末周了，来摸摸鱼记录一下 Bustub Concurrency Control 的实现过程。</p><p>非常感谢 CMU 慷慨地开源如此优质的课程。</p><h2 id=resources>Resources<a hidden class=anchor aria-hidden=true href=#resources>#</a></h2><ul><li><a href=https://15445.courses.cs.cmu.edu/fall2022>https://15445.courses.cs.cmu.edu/fall2022</a> 课程官网</li><li><a href=https://github.com/cmu-db/bustub>https://github.com/cmu-db/bustub</a> Bustub Github Repo</li><li><a href=https://www.gradescope.com/>https://www.gradescope.com/</a> 自动测评网站 GradeScope，course entry code: PXWVR5</li><li><a href=https://discord.gg/YF7dMCg>https://discord.gg/YF7dMCg</a> Discord 论坛，课程交流用</li><li>bilibili 有搬运的课程视频，自寻。</li></ul><p><strong>请不要将实现代码公开，尊重 Andy 和 TAs 的劳动成果！</strong></p><h2 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h2><p>Project 4 是 15-445 2022Fall 的最后一个部分了，在这里我们将为 Bustub 实现关系数据库中极其重要的 transaction 概念。难度上来说个人感觉 Project 2 &#187; 4 > 3 ≈ 1。Project 4 实现难度还是不小的，分为三个部分：</p><ul><li>Lock Manager：锁管理器，利用 2PL 实现并发控制。支持 <code>REPEATABLE_READ</code>、<code>READ_COMMITTED</code> 和 <code>READ_UNCOMMITTED</code> 三种隔离级别，支持 <code>SHARED</code>、<code>EXCLUSIVE</code>、<code>INTENTION_SHARED</code>、<code>INTENTION_EXCLUSIVE</code> 和 <code>SHARED_INTENTION_EXCLUSIVE</code> 五种锁，支持 table 和 row 两种锁粒度，支持锁升级。Project 4 重点部分。</li><li>Deadlock Detection：死锁检测，运行在一个 background 线程，每间隔一定时间检测当前是否出现死锁，并挑选合适的事务将其 abort 以解开死锁。</li><li>Concurrent Query Execution：修改之前实现的 <code>SeqScan</code>、<code>Insert</code> 和 <code>Delete</code> 算子，加上适当的锁以实现并发的查询。</li></ul><h2 id=task-1-lock-manager>Task 1 Lock Manager<a hidden class=anchor aria-hidden=true href=#task-1-lock-manager>#</a></h2><p>大部分需要注意的内容都在 <code>lock_manager.h</code> 的 LOCK NOTE 和 UNLOCK NOTE 里了。在开始实现前务必阅读。</p><p>首先理一理 Lock Manager 的结构：</p><ul><li><code>table_lock_map_</code>：记录 table 和与其相关锁请求的映射关系。</li><li><code>row_lock_map_</code>：记录 row 和与其相关锁请求的映射关系。</li></ul><p>这两个 map 的值均为锁请求队列 <code>LockRequestQueue</code>：</p><ul><li><code>request_queue_</code>：实际存放锁请求的队列。</li><li><code>cv_</code> & <code>latch_</code>：条件变量和锁，配合使用可以实现经典的等待资源的模型。</li><li><code>upgrading_</code>：正在此资源上尝试锁升级的事务 id。</li></ul><p>锁请求以 <code>LockRequest</code> 类表示：</p><ul><li><code>txn_id_</code>：发起此请求的事务 id。</li><li><code>lock_mode_</code>：请求锁的类型。</li><li><code>oid_</code>：在 table 粒度锁请求中，代表 table id。在 row 粒度锁请求中，表示 row 属于的 table 的 id。</li><li><code>rid_</code>：仅在 row 粒度锁请求中有效。指 row 对应的 rid。</li><li><code>granted_</code>：是否已经对此请求授予锁？</li></ul><p>Lock Manager 的作用是处理事务发送的锁请求，例如有一个 SeqScan 算子需要扫描某张表，其所在事务就需要对这张表加 S 锁。而加读锁这个动作需要由 Lock Manager 来完成。事务先对向 Lock Manager 发起加 S 锁请求，Lock Manager 对请求进行处理。如果发现此时没有其他的锁与这个请求冲突，则授予其 S 锁并返回。如果存在冲突，例如其他事务持有这张表的 X 锁，则 Lock Manager 会阻塞此请求（即阻塞此事务），直到能够授予 S 锁，再授予并返回。</p><p>现在可能还有点迷糊，接下来理一理 lock 和 unlock 的整个过程应该就比较清晰了。</p><h3 id=lock>Lock<a hidden class=anchor aria-hidden=true href=#lock>#</a></h3><p>以 table lock 为例。首先需要注意，Project 4 中细节极多，每次操作都有很多状态需要同步和维护，因此尽量遵循防御性编程的理念，多用 assert，确保系统处于预期的状态。</p><p><strong>第一步，检查 txn 的状态。</strong></p><p>若 txn 处于 Abort/Commit 状态，抛逻辑异常，不应该有这种情况出现。</p><p>若 txn 处于 Shrinking 状态，则需要检查 txn 的隔离级别和当前锁请求类型：</p><pre tabindex=0><code>REPEATABLE_READ:
   The transaction is required to take all locks.
   All locks are allowed in the GROWING state
   No locks are allowed in the SHRINKING state
   
READ_COMMITTED:
   The transaction is required to take all locks.
   All locks are allowed in the GROWING state
   Only IS, S locks are allowed in the SHRINKING state
   
READ_UNCOMMITTED:
   The transaction is required to take only IX, X locks.
   X, IX locks are allowed in the GROWING state.
   S, IS, SIX locks are never allowed
</code></pre><p>三种隔离级别翻译成中文分别是可重复读、读已提交、读未提交。另外 lecture 中一直提到的 <code>SERIALIZABLE</code> 可串行化隔离级别在 Project 4 中无需实现。实现 <code>SERIALIZABLE</code> 需要在 <code>REPEATABLE_READS</code> 的基础上加上 index lock。这里我们无需关注 index lock。</p><p>以下是 15-445 Lecture 17 slides 中的截图，介绍了不同隔离级别下可能出现的异常情况：</p><p><img loading=lazy src=../../imgs/15-445-4-1.png alt></p><p>不同的隔离级别其实是性能与一致性的权衡。关于隔离级别的更多内容可以看看 15-445 的 Lecture。</p><p>在 Project 4 中仅需支持除了 <code>SERIALIZABLE</code> 外的剩下三种隔离级别。若 txn 处于 Shrinking 状态：</p><ul><li>在 <code>REPEATABLE_READ</code> 下，造成事务终止，并抛出 <code>LOCK_ON_SHRINKING</code> 异常。</li><li>在 <code>READ_COMMITTED</code> 下，若为 IS/S 锁，则正常通过，否则抛 <code>LOCK_ON_SHRINKING</code>。</li><li>在 <code>READ_UNCOMMITTED</code> 下，若为 IX/X 锁，抛 <code>LOCK_ON_SHRINKING</code>，否则抛 <code>LOCK_SHARED_ON_READ_UNCOMMITTED</code>。</li></ul><p>若 txn 处于 Growing 状态，若隔离级别为 <code>READ_UNCOMMITTED</code> 且锁类型为 S/IS/SIX，抛 <code>LOCK_SHARED_ON_READ_UNCOMMITTED</code>。其余状态正常通过。</p><p>第一步保证了锁请求、事务状态、事务隔离级别的兼容。正常通过第一步后，可以开始尝试获取锁。</p><p><strong>第二步，获取 table 对应的 lock request queue。</strong></p><p>从 <code>table_lock_map_</code> 中获取 table 对应的 lock request queue。注意需要对 map 加锁，并且为了提高并发性，在获取到 queue 之后立即释放 map 的锁。若 queue 不存在则创建。</p><p><strong>第三步，检查此锁请求是否为一次锁升级。</strong></p><p>首先，记得对 queue 加锁。</p><p>granted 和 waiting 的锁请求均放在同一个队列里，我们需要遍历队列查看有没有与当前事务 id（我习惯叫做 tid）相同的请求。如果存在这样的请求，则代表当前事务在此前已经得到了在此资源上的一把锁，接下来可能需要锁升级。需要注意的是，这个请求的 <code>granted_</code> 一定为 true。因为假如事务此前的请求还没有被通过，事务会被阻塞在 LockManager 中，不可能再去尝试获取另一把锁。</p><p>现在我们找到了此前已经获取的锁，开始尝试锁升级。首先，判断此前授予锁类型是否与当前请求锁类型相同。若相同，则代表是一次重复的请求，直接返回。否则进行下一步检查。</p><p>接下来，判断当前资源上是否有另一个事务正在尝试升级（<code>queue->upgrading_ == INVALID_TXN_ID</code>）。若有，则终止当前事务，抛出 <code>UPGRADE_CONFLICT</code> 异常。因为不允许多个事务在同一资源上同时尝试锁升级。</p><blockquote><p>[LOCK UPGRADE] Furthermore, only one transaction should be allowed to upgrade its lock on a given resource. Multiple concurrent lock upgrades on the same resource should set the TransactionState as ABORTED and throw a TransactionAbortException (UPGRADE_CONFLICT).</p></blockquote><p>为什么不允许？TODO!</p><p>然后，判断升级锁的类型和之前锁是否兼容，不能反向升级。</p><blockquote><p>While upgrading, only the following transitions should be allowed:
IS -> [S, X, IX, SIX]
S -> [X, SIX]
IX -> [X, SIX]
SIX -> [X]</p></blockquote><p>若不兼容，抛 <code>INCOMPATIBLE_UPGRADE</code> 异常。</p><p>现在，我们终于可以进行锁升级了。引用 <a href=https://discord.com/channels/724929902075445281/1014055970634215434>Discord</a> 里 15-445 TA 的原话，锁升级可以被拆分成三个步骤：</p><ol><li>可以升级吗？即我们此前的一系列判断。</li><li>释放当前已经持有的锁，并在 queue 中标记我正在尝试升级。</li><li>等待直到新锁被授予。</li></ol><p>需要特别注意的是，在锁升级时，需要先释放此前持有的锁，把升级作为一个新的请求加入队列。之前我以为在锁升级时要一直持有此前的锁，直到能够升级时，再直接修改锁的类型。按此实现之后被一个 test case 卡到怀疑人生。</p><p>锁升级的步骤大概就是这样。当然，假如遍历队列后发现不存在与当前 tid 相同的请求，就代表这是一次平凡的锁请求。</p><p><strong>第四步，将锁请求加入等待队列。</strong></p><p>new 一个 LockRequest，加入队列尾部。实际上这里 LockRequest 不应该设计成裸指针，不方便管理，之后要记得手动释放。最好用智能指针。没用智能指针的原因是忘了（不过完全可以自己改成智能指针。</p><p>这里采用一条队列，把 granted 和 waiting 的请求放在一起，个人感觉不是特别清晰。或许可以改成一条 granted 队列和一条 waiting 队列。</p><p><strong>第五步，尝试获取锁。</strong></p><p>这是最后一步，也是最核心的一步，体现了 Lock Manager 的执行模型。首先，需要清楚条件变量的使用场景。</p><p>条件变量并不是某一个特定语言中的概念，而是操作系统中线程同步的一种机制。先给出条件变量经典的使用形式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>unique_lock</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>lock</span><span class=p>(</span><span class=n>latch</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>resource</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cv</span><span class=p>.</span><span class=n>wait</span><span class=p>(</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>条件变量与互斥锁配合使用。首先需要持有锁，并查看是否能够获取资源。这个锁与资源绑定，是用来保护资源的锁。若暂时无法获取资源，则调用条件变量的 wait 函数。调用 wait 函数后，latch 将自动<strong>释放</strong>，并且当前线程被挂起，以节省资源。这就是阻塞的过程。此外，允许有多个线程在 wait 同一个 latch。</p><p>当其他线程的活动使得资源状态发生改变时，需要调用条件遍历的 <code>notify_all()</code> 函数。即</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// do something changing the state of resource...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cv</span><span class=p>.</span><span class=n>notify_all</span><span class=p>();</span>
</span></span></code></pre></div><p><code>notify_all()</code> 可以看作一次广播，会唤醒所有正在此条件变量上阻塞的线程。在线程被唤醒后，其仍处于 wait 函数中。在 wait 函数中尝试获取 latch，若成功获取则返回，再次检查是否能获取 resource，若仍不能获取，就继续进入 wait 阻塞，释放锁，挂起线程。若能获取，则退出循环。这样就实现了阻塞等待资源的模型。条件变量中的条件指的就是满足某个条件，在这里即能够获取资源。</p><p>理解条件变量的作用后，就可以写出如下代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>unique_lock</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>lock</span><span class=p>(</span><span class=n>queue</span><span class=o>-&gt;</span><span class=n>latch_</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>GrantLock</span><span class=p>(...))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=o>-&gt;</span><span class=n>cv_</span><span class=p>.</span><span class=n>wait</span><span class=p>(</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在 <code>GrantLock()</code> 中，Lock Manager 会判断是否可以满足当前锁请求。若可以满足，则返回 true，事务成功获取锁，并退出循环。若不能满足，则返回 false，事务暂时无法获取锁，在 wait 处阻塞，等待资源状态变化时被唤醒并再次判断是否能够获取锁。资源状态变化指的是什么？有其他事务释放了锁。</p><p>接下来是 <code>GrantLock()</code> 函数。在此函数中，我们需要判断当前锁请求是否能被满足。</p><ol><li><p>判断兼容性。遍历请求队列，查看当前锁请求是否与所有的已经 granted 的请求兼容。需要注意的是，在我的实现中 granted 请求不一定都在队列头部，因此需要完全遍历整条队列。锁兼容矩阵可以在 Lecture slides 中查看。若全部兼容，则通过检查。否则直接返回 false。当前请求无法被满足。</p></li><li><p>判断优先级。锁请求会以严格的 FIFO 顺序依次满足。只有当前请求为请求队列中优先级最高的请求时，才允许授予锁。优先级可以这样判断：</p><ul><li>如果队列中存在锁升级请求，若锁升级请求正为当前请求，则优先级最高。否则代表其他事务正在尝试锁升级，优先级高于当前请求。</li><li>若队列中不存在锁升级请求，则遍历队列。如果，当前请求是第一个 waiting 状态的请求，则代表优先级最高。如果当前请求前面还存在其他 waiting 请求，则要判断当前请求是否前面的 waiting 请求兼容。若兼容，则仍可以视为优先级最高。若存在不兼容的请求，则优先级不为最高。</li></ul></li></ol><p>这么说可能比较抽象，举几个具体的例子：</p><pre tabindex=0><code>X(waiting) X(upgrading)
            ^ current
Current request is upgrading. Highest priority.                      
--------------------------------------------------
X(waiting) S(waiting)
            ^ current
Current request is incompatible with the first request. 
Not highest priority.
--------------------------------------------------
S(waiting) S(waiting)
            ^ current
Although current request is not the first waiting request,
it is compatible with the first request. Highest priority.         
</code></pre><p>其他的情况都比较好理解，遵循升级请求优先级最高和 FIFO 的原则。但最后一种情况可能稍微不太好理解。之所以要这么做是因为 LOCK NOTE 里有这么一句话：</p><blockquote><p>If there are multiple compatible lock requests, all should be granted at the same time as long as FIFO is honoured.</p></blockquote><p>所有兼容的锁请求需要一起被授予。</p><p>两项检查通过后，代表当前请求既兼容又有最高优先级，因此可以授予锁。授予锁的方式是将 <code>granted_</code> 置为 true。并返回 true。假如这是一次升级请求，则代表升级完成，还要记得将 <code>upgrading_</code> 置为 <code>INVALID_TXN_ID</code>。</p><p>另外，需要进行一些 Bookkeeping 操作。Transaction 中需要维护许多集合，分别记录了 Transaction 当前持有的各种类型的锁。方便在事务提交或终止后全部释放。</p><p>Lock 的流程大致如此，row lock 与 table lock 几乎相同，仅多了一个检查步骤。在接收到 row lock 请求后，需要检查是否持有 row 对应的 table lock。必须先持有 table lock 再持有 row lock。</p><h3 id=unlock>Unlock<a hidden class=anchor aria-hidden=true href=#unlock>#</a></h3></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.eleven.wiki/tags/database/>Database</a></li></ul><nav class=paginav><a class=next href=https://blog.eleven.wiki/posts/cmu15-445-project3-query-execution/><span class=title>Next »</span><br><span>CMU15-445 Project3 Query Execution</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://blog.eleven.wiki>Eleven's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>